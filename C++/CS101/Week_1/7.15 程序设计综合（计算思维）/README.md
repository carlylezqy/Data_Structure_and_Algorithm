## 【任务 1.1】谁做的好事？
清华附中有四位同学中的一位做了好事，不留名，表扬信来了之后，校长问这四位是谁做的好事。
A说：不是我。B说：是C。C说：是D。
D说：他胡说。

已知：三个人说的是真话，一个人说的是假话。现在请你根据这些信息，编写程序找出做了好事的人。

## 【任务 1.1】思考题  
某地刑侦大队对涉及六个嫌疑人的一桩疑案进行分析，以下内容叙述的是刑侦队搜集到的线索和情报：

A、B 至少有一人作案；  
A、E、F 三人中至少有两人参与作案；  
A、D 不可能是同案犯；  
B、C 或同时作案，或与本案无关；  
C、D 中有且仅有一人作案；  
如果 D 没有参与作案，则 E 也不可能参与作案。  

请你编写程序，将作案人找出来。

## 【任务 1.2】下楼
从楼上走到楼下共有 $h$ 个台阶，每一步有三种走法
+ 走一个台阶；
+ 走二个台阶；
+ 走三个台阶。

问：一共可以走出多少种方案？即共要多少步？每一步走几级台阶？

解题思路:A  
```C++
void Downstairs_A(int i,int step);
```
1. 一共有（下1、2、3阶）三种走法。
2. 如果可以继续往下走则继续执行（剩余台阶数 $i$ 大于或等于要走的台阶数 $j$ ）
3. 将要走的台阶数 $j$ 记录到步骤
判断：若当剩余台阶数 $i$ 刚好等于要走的台阶数 $j$
则：输出步骤；否则：递归执行走完要走台阶数 $j$ 后剩余的台阶数 $i-j$

解题思路:B  
```C++
void Downstairs_B(int height, int step);
```
1. 若剩余的台阶数 $height$ 为 $0$ 则输出步骤并终止递归。
2. 循环（下1、2、3阶）三种走法
3. 计算新高度并检查数值是否合法（$ height > 0 $）
4. 若为合法性为真，则记录当前走法，并递归执行剩余台阶数 $height - j$

## 【任务 1.3】跳马
在半张中国象棋的棋盘上，一只马从左下角跳到右上角，只允许往右跳，不允许往左跳，问能有多少种跳步方案。要求：输出方案数和各方案的具体跳法。

解题思路 1: 第 $step$ 步从 $(x, y)$ 开始遍历
遍历从当前位置 $(x, y)$ 出发到下一跳 $(x', y')$ 的所有可能性，并对各种可能性得到的方案进行记录，累计方案的总数。
对 $(x', y')$ 进行判断。非法、到达或继续。  
解题思路 2: 先判断中止，再枚举递归

### 设计数据结构
1. 马的不同跳法 (使用数组来记录)
```C++
int dx = {1, 2, 2, 1}, dy[] = {2, 1, -1, -2};
```
2. 操作步骤记录（二维数组，其中包含跳步的次序和位置坐标）
每一步记录两个值 path[step][0], path[step][1]

```C++
for i from 0 to 4 do:
    (x, y) -> (x + dx[i], y + dy[i]) 
```
3. 以上定义为全局变量
4. 当前总的方案数也用一个全局变量num来表示

### 经验1：用结构类型来表示落点坐标
```C++
struct position {int x, y;};
```
### 经验2：自定义函数检查落点坐标
```C++
bool IsValid(position pos) {
    return (pos.x >= 0) && (pos.x <= 8) && (pos.y >= 0) && (pos.y <= 4);
}
bool IsGoal(position pos) {return (pos.x == goal_pos.x) && (pos.y == goal_pos.y);}
```

## 【任务 1.4】分书
有编号分别为0、1、2、3、4的五本书，准备分给A、B、C、D、E五个人。请你写一个程序，输出所有的分书方案，要求每个分书方案都能让每个人都皆大欢喜（即每人都分到感兴趣的书）。    
假定这5个人对5本书的阅读兴趣如下表：

||0|1|2|3|4|
|:-|:-|:-|:-|:-|:-|
|A|0|0|1|1|0|
|B|1|1|0|0|1|
|C|0|1|1|0|1|
|D|0|0|0|1|0|
|E|0|1|0|0|1|

解题思路（数据结构设计）
1. 阅读兴趣用一个二维数组描述
2. 书籍状态用一个一维数组描述
## 【任务 1.5】八皇后问题
在国际象棋的棋盘上，放置8个皇后（棋子），使皇后两两之间互不攻击。
八皇后问题的来源：国际西洋棋棋手马克斯·贝瑟尔于1848年提出。八皇后问题的第一个解在1850年由弗朗兹·诺克给出，他也是将问题推广到 $N$ 皇后摆放的人之一  
Chess composer Max Bezzel published the eight queens puzzle in 1848. Franz Nauck published the first solutions in 1850. Nauck also extended the puzzle to the $n$ queens problem， with n queens on a chessboard of $n * n$ squares

### 解题思路1：暴力枚举


所谓互不攻击，是说任何两个皇后都要满足
1. 不在棋盘的同一行；
2. 不在棋盘的同一列；
3. 不在棋盘的同一对角线上。

若已知8个皇后的位置，怎样判断它们是否可以相互攻击？
即：是否有两个以上的皇后位于同一行、同一列、同一对角线上？

存在两种不同的算法（实现思路）：
1. 以皇后为枚举对象，对皇后两两之间进行攻击性的判断，按行或列的次序，将每一个皇后跟前面所有皇后依次进行攻击判断（类似“插入排序”的思想）
2. 以行、列、对角线为枚举对象，统计各方向上的皇后数量（类似“词频统计”的思想）

### 解题思路2：何必暴力枚举
从第一列开始逐一摆放皇后，直至8列均放上皇后
+ 对于第i个皇后（在第 $i$ 列），逐一检查该列的8行，判断是否会被前 $i-1$ 个皇后攻击到，选择一个安全位置。
+ 当8个皇后都成功放到棋盘上之后，这个布局就是题目的一个解。
+ 为了找到所有可能的解，需要记录下这一布局，然后继续尝试其他可能的行（对各列均应如此）。

### 解题思路3：枚举思想+递归算法
假定按列摆放皇后。棋盘共有8列（横轴方向），每列能有且只能有一个皇后，至多能放8个皇后。因此，这8个皇后“分别应该放在哪一行上（纵轴方向）？”就成为求解任务要回答的问题。
我们采用试探方法：“向前走（放置皇后），碰壁回头（取走皇后）″的策略，即“回溯法″的解题思路。

定义函数 Try(i) ：将第 $i$ 个皇后放到棋盘上。由于棋盘的对称性，我们假定是逐列放置皇后将第 $i$ 列的皇后放在 $j$ 行位置上之后（如果该位置是安全的话），棋盘各位置安全性将发生变化（对未来放置皇后过程有影响在放第i列的皇后时，第 $i$ 列上应还没有皇后（因为是按列依次来摆放的），不会在列上遭到其它皇后的攻击，因此只用考虑来自当前行和两个对角线上已有皇后的攻击。

对棋盘上指定位置的安全性进行判断
```C++
int Num; //计量方案个数

int Q[9]; //八皇后所占用的行号
bool S[9], L[17], R[17]; //行、左右斜对角线、右左斜对角线是否安全
const int OFFSET = 9; // 统一数组下标范围 [2, 3, ...,16]
```
## 【任务 1.6】人鬼渡河
目标：将东岸的3人3鬼通过一只小船安全转移到西岸，希望摆渡次数尽可能少。
条件：
+ 船的容量有限，一次最多只能坐2人（或2鬼或1人1鬼）。
+ 无论是在河的东岸还是在河的西岸，一旦鬼数多于人数，则人将被鬼吃掉。
+ 怎样渡河的大权掌握在人的手中说明：划船的时间忽略不计。船一靠岸即将船与岸视为一体，人和鬼即使还没有下船也视为已上岸。
任务：编写程序，求出一种渡河方案。

目标：找一种“方案”，能将人鬼安全摆渡至对岸。
方案：一系列“指令”
指令：？？？？？？？
A —> B :: 将一个事物，转变成另一个事物。
考虑到“计算机”的能力（与特长），指令必须是对“数”的运算（即将一个数转变成为另一个数）。
因此，确定“指令”之前，需要确定是哪些“数”在被计算！它们是什么？

### 编程经验
在“跳马”和“分书”这两个问题中，解题的关键是：
+ 将棋子移动过程转变成坐标平面上运动点的坐标变化，以及将读者与书籍之间的约束条件（规则）用矩阵元素来表示。
+ 求解过程是在所有可能的变化决策中，分阶段寻找满足要求的决策。这是一种特殊的枚举。
### 编程技巧
对于上面的摆渡过程，可被计算的到底是什么？
或者说，玩游戏过程中的“操作”，对应的数学上的描述是什么再或者说：操作过程中所改变的，能用什么数学概念来刻画？
归根结底，问题的数学模型是什么？

+ 西岸的数量（$A$）在变化
+ 东岸的数量（$B$）在变化
+ 船中的数量（$C$）在变化
+ 航行方向也在变化

两岸人鬼数量的变化是由渡船上的人鬼数量与船的运动方向决定的
$$ A+B+C=D $

设人数用R表示，鬼数用G表示，则每一个渡河中的“东岸场景”都与个数对 $(R,G)$ 相对应。东岸所有可能场景（人鬼数），会组成平面上的一个网格。

|G\R|0|1|2|3|
|:-|:-|:-|:-|:-|
|3|(0, 3)|(1, 3)|(2, 3)|(3, 3)|
|2|(0, 2)|(1, 2)|(2, 2)|(3, 2)|
|1|(0, 1)|(1, 1)|(2, 1)|(3, 1)|
|0|(0, 0)|(1, 0)|(2, 0)|(3, 0)|

解题思路（数学模型）：操作数字化
设 $K$ 为摆渡行船的次数（序号，从1开始计数），从东岸到西岸或从西岸到东岸记1次。

$$ S_{K+1} = S_{K} + \Delta_{K} $$

显然：
+ 船从东到西时，K为奇数；
+ 船从西到东时，K为偶数。

## 【任务 1.7】人鬼渡河 2.0
目标：将东岸的3人3鬼通过一只小船安全转移到西岸，希望摆渡次数尽可能少
条件：
+ 船的容量有限，一次最多只能坐2人（或2鬼或1人1鬼）。
+ 无论是在河的东岸还是在河的西岸，一旦鬼数多于人数，则人被鬼扔到河中
+ 怎样渡河的大权掌握在人的手中。
任务：编写程序，求出所有的渡河方案，要求没有多余的重复步骤。

### 解题思路：视渡河操作为特殊的“跳马”
视某一时刻东岸的（人, 鬼）数对，是状态空间中的坐标点！
于是：
+ 任务转换为从起点状态 $(3, 3)$ “跳”到终点状态 $(0, 0)$
坐标变化操作规则按照题目关于安全性的要求，可得
```C++
dxy[]={1,0}, {0,1}, {1,1}, {2,0}, {0,2}};
```
+ 对每一个状态，枚举尝试所有可能的决策
+ 若当前状态与终点状态一致，则输出此方案

使用枚举+递归来解决

## 【任务 1.7】思考题1 青蛙换位游戏 🐸
🐸🍀🐸🐸

## 【任务 1.7】思考题2 华容道
请编程输出完成【华容道】任务的操作步骤
## 【任务 1.7】思考题3
两个水瓶，一个容量是 9 升，一个容量是 4 升，如何才能从河中取出 6 升水？  
请编程输出操作步骤。

## 【任务 2.1】对比下楼问题与跳马问题
观察下楼问题和跳马问题的解题思路（与或图）  
下楼问题（上）和跳马问题（下）的与或图基本相同，说明它们在算法上是同一类问题，可以使用基本相同的程序来求解。
两个问题的差异：  
1. 是否达到目标 
2. 新位置的计算
3. 判断是否合法

下楼跳马问题的通用算法框架
.....
## 【任务 2.2】对比分书问题与八皇后问题
观察分书问题和八皇后问题的解题思路（与或图）
分书问题（上）和八皇后问题（下）的与或图基本相同，说明它们在算法上是同一类问题，可以使用基本相同的程序来求解。


经过对比，发现它们都可抽象成同一问题，即在限定条件下设置矩阵元素。
共同都有的限定缘件是：行列不重复、不遗漏。而在八皇后任务中，又增加了一个限定条件，即每条斜线上只能设置一个元素。

当然，这两个问题也有区别：
1. 分书问题中，可以设置元素的位置是矩阵的一个子集，即题面描述中给出的用户与图书之间的喜好关系表。
2. 八皇后向题中，所有位置均可以选择，没有限制。【如果棋盘有窟窿，增加了限制，那就另当别论了】

分书和八皇后问题的通用算法框架
.....
## 【任务 2.2】能否使用同一个算法框架，求解下楼跳马分书八皇后？

## 【任务 2.3】填充数字旋转方阵
考虑这么一个任务：编程输出 $N*N$ 的数字方阵，将 $ 1 ~ N*N $ 的自然数逆时针旋转填充到矩阵中。例如一个 $6*6$ 的矩阵完成填充后的示意图如下所示。
## 【任务 2.4】用 OOP 来解决矩阵填充

## 【任务 2.5】深入思考：矩阵到底是什么
在下面的接口示意图中：  
用 $M$ 表示矩阵的数学运算接口，如矩阵的加、减、乘、除、幂、逆等常见数学运算，目前的旋转方阵类示例中没有实现。  
用 $F$ 表示旋转填充的操作接口。

矩阵到底是什么？
回归矩阵的数学的本质：结构化的多维数据
填充操作（接口 F）只是一种特定的算法操作，它并不是矩阵这个数学概念所固有的！它也可以用来填充其他“形状”，如三角形。

## 【任务 2.6】深入思考：填充算法是什么
回归填充的算法本质:按指定规则，依次生成位置信息。
不同规则的共性如何抽取？如何描述？
自定义“语言”，用符号表示规则


## 【任务 2.6】思考题
1. 如果旋转方向从逆时针变成顺时针，则程序应该如何修改？
2. 如果希望两种旋转方向的填充策略都能支持，程序又应该如何修改？
3. 更进一步地，如果希望扩展到其他类型的填充次序，如蛇形、Z 字形、U 字形等，应该如何修改类的对外接口与具体实现？

|代号|功能|
|:----|:---|
|DRUL|逆时针旋转|
|RDLU|顺时针旋转|
|DrUr|U字一型|
|RdLd|U字二型|
|dZrz|Z字一型|
|rzdZ|Z字二型|

借鉴思考1：标准模板库STL
## 【任务 2.7】深入思考：规则到底是什么
关于如何填充前进的指令，不同“填充要求”对应不同的规则指令，所以“规则”在本质上是独立于填充算法而单独存在的。

矩阵-填充-规则三者的关系
算法（Filler）、容器（Matrix）、迭代器（Rule）

## 【任务 2.7】思考题
如果被填充的是迷宫，要求根据指定规则，生成从入口到出口的路径（即坐标序列），则应如何抽象它们的共性？

借鉴思考2：正则表达式